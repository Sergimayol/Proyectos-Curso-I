*-----------------------------------------------------------
* Title      : PRAFIN21
* Written by : Joan Gomila Morales,Mateu Joan Perello
* Date       : 31/05/2021
* Description: Emulador de la CDB
*-----------------------------------------------------------
    ORG $1000
EPROG: DC.W $E088,$C0E2,$6050,$9042,$0000,$8842,$9802,$0000,$FFFF
EIR:    DC.W 0 ;eregistro de instruccion
EPC:    DC.W 0 ;econtador de programa
ER0:    DC.W 0 ;eregistro R0
ER1:    DC.W 0 ;eregistro R1
ER2:    DC.W 0 ;eregistro R2
ER3:    DC.W 0 ;eregistro R3
ER4:    DC.W 0 ;eregistro R4
ER5:    DC.W 0 ;eregistro R5
ET6:    DC.W 0 ;eregistro T6
ET7:    DC.W 0 ;eregistro T7
ESR:    DC.W 0 ;eregistro de estado (00000000 00000NCZ)




START:
    
    CLR.W EPC

FETCH:

    ;--- IFETCH: INICIO FETCH
        ;*** En esta seccion debeis introducir el codigo necesario para cargar
        ;*** en el EIR la siguiente instruccion a ejecutar, indicada por el EPC
	    ;*** y dejar listo el EPC para que apunte a la siguiente instruccion
		
	; ESCRIBID VUESTRO CODIGO AQUI
	LEA EPROG,A3 ;METEMOS DIRECCION DE EPROG EN A3
	MOVE.W EPC,D4
   	 MULS.W #2,D4
    	ADD.W A3,D4
    	MOVE.W D4,A2
    	MOVE.W (A2),EIR ;   EIR<--[[A2]]
    	ADDQ.W #1,EPC 
   
       
    ;--- FFETCH: FIN FETCH 
      ;--- IBRDECOD: INICIO SALTO A DECOD
        ;*** En esta seccion debeis preparar la pila para llamar a la subrutina
        ;*** DECOD, llamar a la subrutina, y vaciar la pila correctamente,
        ;*** almacenando el resultado de la decodificacion en D1
   
 ; ESCRIBID VUESTRO CODIGO AQUI
	SUBQ.W #2,SP ;RESERVAMOS ESPACIO PARA RESULTADO
	MOVE.W EIR,-(SP) ;PASAMOS EIR COMO PARÃ€METRO DE ENTRADA
	JSR DECOD
	ADDQ.W #2,SP    ;liberamos espacio del parÃ metro de entrada
    MOVE.W (SP)+,D1 ;EN D1 TENEMOS EL CODIGO CORRESPONDIENTE DE LA INSTRUCCIÃ“N

	

    ;--- FBRDECOD: FIN SALTO A DECOD
    
    ;--- IBREXEC: INICIO SALTO A FASE DE EJECUCION
        ;*** Esta seccion se usa para saltar a la fase de ejecucion
        ;*** NO HACE FALTA MODIFICARLA
    MULU #6,D1
    MOVEA.L D1,A1
    JMP JMPLIST(A1)
    
JMPLIST:
    JMP EHLT
    JMP EJMN
    JMP EJMZ
    JMP EJMI
    JMP ECOM
    JMP EADD
    JMP ESUB
    JMP ENEG
    JMP EAND
    JMP EOR
    JMP ENOT
    JMP ESET
    JMP EMOV
    JMP ESTO
    JMP ELOA
    
    ;--- FBREXEC: FIN SALTO A FASE DE EJECUCION
    
    ;--- IEXEC: INICIO EJECUCION
        ;*** En esta seccion debeis implementar la ejecucion de cada einstr.
	
	; ESCRIBID EN CADA ETIQUETA LA FASE DE EJECUCION DE CADA INSTRUCCION
	
EHLT:
    SIMHALT

EJMN:

	MOVE.W ESR,D6 ;MOVEMOS REGISTRO ESR
	BTST.L #2,D6 ;MIRAMOS VALOR DE BIT N
	BEQ FETCH
	AND.W #$0FF0,EIR ;SACAMOS EL VALOR DE LA DIRECCION M
	MOVE.W EIR,D0
	LSR.L #4,D0
	MOVE.W D0,EPC ;METEMOS DIRECCIÃ“N M EN EL EPC
	JMP FETCH
    
EJMZ:
	MOVE.W ESR,D6 ;MOVEMOS REGISTRO ESR
	BTST.L #0,D6 ;MIRAMOS ES VALOR DE Z 
	BEQ FETCH
	AND.W #$0FF0,EIR ;OBTENEMOS VALOR DE M
	MOVE.W EIR,D0
	LSR.L #4,D0
	MOVE.W D0,EPC
	JMP FETCH

EJMI:
	AND.W #$0FF0,EIR
	MOVE.W EIR,D0
	LSR.L #4,D0
	MOVE.W D0,EPC
	JMP FETCH
	
ECOM:
    AND.W #$00FF,EIR ;OBTENEMOS VALOR DE A Y B
    MOVE.W EIR,D0 ;copiamos ir a d3
    AND.W #$000F,D0 ;en D3 tenemos b
    MOVE.W EIR, D4 
    LSR.L #5,D4 ;En d4 tenemos A
    ;HACEMOS UN SALTO A SUBRRUTINA  PARA CONOCER XA Y XB
   SUBQ.W #2,SP ;RESRVAMOS ESPACIO PARA DEVOLVER direccion del registro XB
  SUBQ.W #2,SP ;RESERVAMOS ESPACIO PARA DEVOLVER CONTENIDO DE XB
   MOVE.W D3,-(SP) ;PASAMOS XB COMO PARAMETRO DE ENTRADA
   JSR SUBREG
   ADDQ.W #2,SP ;LIBERAMOS ESPACIO PARAMETRO DE ENTRADA
   MOVE.W (SP)+,D3 ;D3 OBTENEMOS EL CONTENIDO DEL REGISTRO XB 
   ADDQ.W #2,SP ;NO INTERESA DIRECCION DE EREGISTRO XB 

  
;REPETIMOS PROCESO PARA OPERANDO XA
   SUBQ.W #2,SP ;RESERVAMOS ESPACIO PARA DIRECION DE XA   
   SUBQ.W #2,SP ;RESERVAMOS ESPACIO PARA DEVOLVER CONTENIDO DE XA
   MOVE.W D4,-(SP) ;PASAMOS COMO PARAMETRO DE ENTRADA D4
   JSR SUBREG
   ADDQ.W #2,SP ;LIBERAMOS PARAMETRO DE ENTRADA
   MOVE.W (A7)+,D4 ;EN D4 TENEMOS EL CONTENIDO DE XA
   ADDQ.W #2,SP ;NO INTERESA DIRECCION DE EREGISTRO XA
   CMP.W D4,D3 ;COMPARAMOS B-A
   
   ;ACTUALIZAMOS LOS EFLAGS
    MOVE.W SR,D5
    MOVE.W ESR,D6
    JSR TODOSFLAGS
    MOVE.W D6,ESR
    JMP FETCH  

EADD:


;SACAMOS VALOR DE  A,B

    AND.W #$00FF,EIR
    MOVE.W EIR,D3 ;copiamos ir a d3
    AND.W #$000F,D3 ;en D3 tenemos b
    MOVE.W EIR, D4 
    LSR.L #5,D4 ;En d4 tenemos A


;HACEMOS UN SALTO A SUBRRUTINA para conocer xa y xb

    SUBQ.W #2,SP ;RESRVAMOS ESPACIO PARA DEVOLVER direccion del registro XB
    SUBQ.W #2,SP ;RESERVAMOS ESPACIO PARA DEVOLVER CONTENIDO DE XB
    MOVE.W D3,-(SP)
    JSR SUBREG
    ADDQ.W #2,SP ;LIBERAMOS ESPACIO PARAMETRO DE ENTRADA
    MOVE.W (SP)+,D3 ;D3 METEMOS EL CONTENIDO DEL REGISTRO XB EN D3
    MOVE.W (SP)+,A0 ;EN A0 TENEMOS DIRECION DEL OPERANDO DESTINO(XB)
	 
;REPETIMOS PROCESO PARA OPERANDO XA

    SUBQ.W #2,SP ;RESERVAMOS ESPACIO PARA DIRECION DE XA   
    SUBQ.W #2,SP ;RESERVAMOS ESPACIO PARA DEVOLVER CONTENIDO DE XA
    MOVE.W D4,-(SP) ;PASAMOS COMO PARAMETRO DE ENTRADA D4
    JSR SUBREG
    ADDQ.W #2,SP ;LIBERAMOS PARAMETRO DE ENTRADA
    MOVE.W (A7)+,D4 ;EN D4 TENEMOS EL CONTENIDO DE XA
    ADD.W #2,SP ;NO INTERESA DIRECCION DEL OPERANDO FUENTE

;OPERAMOS

    ADD.W D4,D3 

;ACTUALIZAMOS LOS EFLAGS CON EL RESULTADO DE SUMAR [XB]
;+[XA]
    
    MOVE.W SR,D5 ;MOVEMOS LOS FLAGS DEL 68K
    MOVE.W ESR,D6 ;ASI PODEMOS MANIPULAR ESR
    JSR TODOSFLAGS
    MOVE.W D6,ESR ;EN ESR TENEMOS LOS FLAGS ACTUALIZADOS
    

;ACTUALIZAMOS REGISTRO INDICADO POR XB QUE ESTA EN D3
     
    MOVE.W D3,(A0)
    
    JMP FETCH

ESUB:

;SACAMOS VALOR DE  A,B

    AND.W #$00FF,EIR
    MOVE.W EIR,D3 ;copiamos ir a d3
    AND.W #$000F,D3 ;en D3 tenemos b
    MOVE.W EIR, D4 
    LSR.L #5,D4 ;En d4 tenemos A

;HACEMOS UN SALTO A SUBRRUTINA para conocer xa y xb

;HACEMOS UN SALTO A SUBRRUTINA para conocer xa y xb
   
    SUBQ.W #2,SP ;RESRVAMOS ESPACIO PARA DEVOLVER direccion del registro XB
    SUBQ.W #2,SP ;RESERVAMOS ESPACIO PARA DEVOLVER CONTENIDO DE XB
    MOVE.W D3,-(SP)
    JSR SUBREG
    ADDQ.W #2,SP ;LIBERAMOS ESPACIO PARAMETRO DE ENTRADA
    MOVE.W (SP)+,D3 ;D3 METEMOS EL CONTENIDO DEL REGISTRO XB EN D3
    MOVE.W (SP)+,A0 ;EN A0 TENEMOS DIRECION DE REGISTRO DESTINO(XB)
	   
;REPETIMOS PROCESO PARA OPERANDO XA

    SUBQ.W #2,SP ;RESERVAMOS ESPACIO PARA DIRECION DE XA   
    SUBQ.W #2,SP ;RESERVAMOS ESPACIO PARA DEVOLVER CONTENIDO DE XA
    MOVE.W D4,-(SP) ;PASAMOS COMO PARAMETRO DE ENTRADA D4
    JSR SUBREG
    ADDQ.W #2,SP ;LIBERAMOS PARÃ€METRO DE ENTRADA
    MOVE.W (A7)+,D4 ;EN D4 TENEMOS EL CONTENIDO DE XA
    ADD.W #2,SP ;NO INTERESA DIRECCION DE EREGISTRO XA

;OPERAMOS

    SUB.W D3,D4 ;

;ACTUALIZAMOS LOS EFLAGS

    
    MOVE.W SR,D5
    MOVE.W ESR,D6
    JSR TODOSFLAGS
    MOVE.W D6,ESR
    
;ACTUALIZAMOS EREGISTRO INDICADO POR XB

    MOVE.W D4,(A0)   
    JMP FETCH
   
ENEG:

    AND.W #$000F,EIR 
    MOVE.W EIR, D3 ;D3 TENEMOS XB 

;HACEMOS UN SALTO A SUBRRUTINA para conocer xb

    SUBQ.W #2,SP ;RESRVAMOS ESPACIO PARA DEVOLVER direccion del registro XB
    SUBQ.W #2,SP ;RESERVAMOS ESPACIO PARA DEVOLVER CONTENIDO DE XB
    MOVE.W D3,-(SP)
    JSR SUBREG
    ADDQ.W #2,SP ;LIBERAMOS ESPACIO PARAMETRO DE ENTRADA
    MOVE.W (SP)+,D3 ;D3 METEMOS EL CONTENIDO DEL REGISTRO XB EN D3
    MOVE.W (SP)+,A0 ;EN A0 TENEMOS DIRECION DE REGISTRO DESTINO(XB)
   
;OPERAMOS

    MULS.W #-1,D3 ;
   
;ACTUALIZAMOS LOS EFLAGS
	
    MOVE.W SR,D5
    MOVE.W ESR,D6
    JSR FLAGSZN
    MOVE.W D6,ESR

   
;ACTUALIZAMOS EREGISTRO INDICADO POR XB
    
    MOVE.W D3,(A0)
    JMP FETCH  

EAND:

;SACAMOS VALOR DE  A,B

    AND.W #$00FF,EIR
    MOVE.W EIR,D3 ;copiamos ir a d3
    AND.W #$000F,D3 ;en D3 tenemos b
    MOVE.W EIR, D4 
    LSR.L #5,D4 ;En d4 tenemos A

;HACEMOS UN SALTO A SUBRRUTINA para conocer xa y xb

;HACEMOS UN SALTO A SUBRRUTINA para conocer xa y xb

    SUBQ.W #2,SP ;RESRVAMOS ESPACIO PARA DEVOLVER direccion del registro XB
    SUBQ.W #2,SP ;RESERVAMOS ESPACIO PARA DEVOLVER CONTENIDO DE XB
    MOVE.W D3,-(SP)
    JSR SUBREG
    ADDQ.W #2,SP ;LIBERAMOS ESPACIO PARAMETRO DE ENTRADA
    MOVE.W (SP)+,D3 ;D3 METEMOS EL CONTENIDO DEL REGISTRO XB EN D3
    MOVE.W (SP)+,A0 ;EN A0 TENEMOS DIRECION DE REGISTRO DESTINO(XB)  

;REPETIMOS PROCESO PARA OPERANDO XA

    SUBQ.W #2,SP ;RESERVAMOS ESPACIO PARA DIRECION DE XA   
    SUBQ.W #2,SP ;RESERVAMOS ESPACIO PARA DEVOLVER CONTENIDO DE XA
    MOVE.W D4,-(SP) ;PASAMOS COMO PARAMETRO DE ENTRADA D4
    JSR SUBREG
    ADDQ.W #2,SP ;LIBERAMOS PARAMETRO DE ENTRADA
    MOVE.W (A7)+,D4 ;EN D4 TENEMOS EL CONTENIDO DE XA
    ADD.W #2,SP ;NO INTERESA DIRECCION DE EREGISTRO XA

;OPERAMOS

    AND.W D3,D4 ;

;ACTUALIZAMOS LOS EFLAGS

     MOVE.W SR,D5
    MOVE.W ESR,D6
    JSR FLAGSZN
    MOVE.W D6,ESR
   
;ACTUALIZAMOS REGISTRO XB Y PASAMOS A LA SIGUIENTE INSTRUCION

    MOVE.W D4,(A0)
    
    JMP FETCH  

EOR:

;SACAMOS VALOR DE  A,B

    AND.W #$00FF,EIR
    MOVE.W EIR,D3 ;copiamos ir a d3
    AND.W #$000F,D3 ;en D3 tenemos b
    MOVE.W EIR, D4 
    LSR.L #5,D4 ;En d4 tenemos A


;HACEMOS UN SALTO A SUBRRUTINA para conocer xa y xb

    SUBQ.W #2,SP ;RESRVAMOS ESPACIO PARA DEVOLVER direccion del registro XB
    SUBQ.W #2,SP ;RESERVAMOS ESPACIO PARA DEVOLVER CONTENIDO DE XB
    MOVE.W D3,-(SP)
    JSR SUBREG
    ADDQ.W #2,SP ;LIBERAMOS ESPACIO PARAMETRO DE ENTRADA
    MOVE.W (SP)+,D3 ;D3 METEMOS EL CONTENIDO DEL REGISTRO XB EN D3
    MOVE.W (SP)+,A0 ;EN A0 TENEMOS DIRECION DE REGISTRO DESTINO(XB) 

;REPETIMOS PROCESO PARA OPERANDO XA

   SUBQ.W #2,SP ;RESERVAMOS ESPACIO PARA DIRECION DE XA   
   SUBQ.W #2,SP ;RESERVAMOS ESPACIO PARA DEVOLVER CONTENIDO DE XA
   MOVE.W D4,-(SP) ;PASAMOS COMO PARAMETRO DE ENTRADA D4
   JSR SUBREG
   ADDQ.W #2,SP ;LIBERAMOS PARAMETRO DE ENTRADA
   MOVE.W (A7)+,D4 ;EN D4 TENEMOS EL CONTENIDO DE XA
   ADD.W #2,SP ;NO INTERESA DIRECCION DE EREGISTRO XA

;OPERAMOS

    OR.W D3,D4 ;

;ACTUALIZAMOS LOS EFLAGS Z Y N CON EL RESULTADO DE LA OPERACION OR XA,XB

     MOVE.W SR,D5
    MOVE.W ESR,D6
    JSR FLAGSZN 
    MOVE.W D6,ESR
   
;ACTUALIZAMOS EREGISTRO INDICADO POR XB

    MOVE.W D4,(A0)   
    JMP FETCH  

ENOT:

    AND.W #$000F,EIR 
    MOVE.W EIR, D3 ;D3 TENEMOS XB 

 ;HACEMOS UN SALTO A SUBRRUTINA PARA CONOCER XB

    SUBQ.W #2,SP ;RESRVAMOS ESPACIO PARA DEVOLVER LA DIRECCION DEL REGISTRO XB
    SUBQ.W #2,SP ;RESERVAMOS ESPACIO PARA DEVOLVER CONTENIDO DE XB
    MOVE.W D3,-(SP)
    JSR SUBREG
    ADDQ.W #2,SP ;LIBERAMOS ESPACIO PARAMETRO DE ENTRADA
    MOVE.W (SP)+,D3 ;D3 METEMOS EL CONTENIDO DEL REGISTRO XB EN D3
    MOVE.W (SP)+,A0 ;EN A0 TENEMOS DIRECION DE REGISTRO DESTINO(XB)

;OPERAMOS

   NOT.W D3 ;


    
;ACTUALIZAMOS LOS EFLAGS Z Y N
    MOVE.W SR,D5
    MOVE.W ESR,D6
    JSR FLAGSZN
    MOVE.W D6,ESR

  
;ACTUALIZAMOS EREGISTRO INDICADO POR XB

    MOVE.W D3,(A0)

ESET:

	AND.W #$0FFF,EIR
	MOVE.W EIR,D4
	LSL.L #1,D4
	MOVE.W D4,D3 ;COPIAMOS REGISTRO IR
	AND.W #$000F,D3 ;SACAMOS LA B
	LSR.L #1,D3
	
 ;HACEMOS UN SALTO A SUBRRUTINA para conocer xb

    SUBQ.W #2,SP ;RESRVAMOS ESPACIO PARA DEVOLVER direccion del registro XB
    SUBQ.W #2,SP ;RESERVAMOS ESPACIO PARA DEVOLVER CONTENIDO DE XB
    MOVE.W D3,-(SP)
    JSR SUBREG
    ADDQ.W #4,SP ;LIBERAMOS ESPACIO PARAMETRO DE ENTRADA Y DE CONTENIDO DE REGISTRO XB,NO INTERESA
    MOVE.W (SP)+,A0 ;EN A0 TENEMOS DIRECION DE REGISTRO DESTINO(XB)

;OBTENEMOS K

    AND.W #$0FF0,D4 ;
    LSR.L #4,D4 ;TENEMOS LA K EN D4
    BTST.L #7,D4 ;MIRAMOS SI BIT MS=1
    BNE ESTENDER ;SI ES 1 ESTENDEMOS SIGNO
    MOVE.W D4,(A0) ;EN D4 YA ESTA K
    BRA EFLAGS        

ESTENDER:

;EXTENDEMOS BIT MS

    OR.W #$FF00, D4
    MOVE.W D4,(A0) 
    JMP EFLAGS
EFLAGS:
	MOVE.W SR,D5
    MOVE.W ESR,D6
    JSR FLAGSZN
    MOVE.W D6,ESR
    JMP FETCH
    
EMOV:

	AND.W #$00FF,EIR
	MOVE.W EIR,D3
	AND.W #$000F,D3
	SUBQ.W #4,SP
	MOVE.W D3,-(SP)
	JSR SUBREG
    ADDQ.W #4,SP ;LIBERAMOS ESPACIO PARAMETRO DE ENTRADA Y DE   CONTENIDO DE REGISTRO XB,
    MOVE.W (SP)+,A0 ;EN A0 TENEMOS DIRECION DE REGISTRO DESTINO(XB)
	AND.W #$00F0,EIR
	MOVE.W EIR,D4
	LSR.L #5,D4 ;EN D4 TENEMOS A
	SUBQ.W #4,SP 
	MOVE.W D4,-(SP) ;PASAMOS A COMO PARÃ€METRO DE ENTRADA
	JSR SUBREG
	ADDQ.W #2,SP
	MOVE.W (SP)+,D4 ;EN D4 TENEMOS EL CONTENIDO DEL REGISTRO XA(OPERANDO)
	ADDQ.W #2,SP
	
	MOVE.W D4,(A0) ;MOVEMOS EL CONTENIDO DEL REGISTRO XA AL XB

	;ACTUALIZAMOS EFLAGS CON EL RESULTADO DE MOVER EL CONTENIDO DEL REGISTRO XA AL XB
	MOVE.W SR,D5
    	MOVE.W ESR,D6
    	JSR FLAGSZN
   	 MOVE.W D6,ESR
	JMP FETCH

ESTO:
	MOVE.W EIR,D3
	AND.W #$0FF0,D3

    LSR.L #4,D3
    MULS.W #2,D3
	MOVE.W D3,A0 ;EN A0 TENEMOS LA DIRECIÓN M
 	AND.W #$000F,EIR ;EN EIR TENEMOS i
 	MOVE.W EIR,D4
	BTST.L #3,D4
	BNE EiT7
	LEA.L EPROG,A4
	ADD A4,A0
	MOVE.W ET6,(A0)
	JMP FETCH
	
EiT7:
    LEA.L EPROG,A4
    ADD.W A4,A0
	MOVE.W ET7,(A0)
	JMP FETCH
	
ELOA:
	MOVE.W EIR,D3
	AND.W #$0FF0,D3
	LSR.L #4,D3
	MULS.W #2,D3
    MOVE.W D3,A0 ;EN A0 TENEMOS LA DIRECION M
    AND.W #$000F,EIR ;EN EIR TENEMOS i
    MOVE.W EIR,D4
	BTST.L #3,D4
	BNE EiT72
    LEA.L EPROG,A4
    ADD.W A4,A0
	MOVE.W (A0),ET6
	;ACTUALIZAMOS FLAGS
	MOVE.W SR,D5
    MOVE.W ESR,D6
    JSR FLAGSZN
   	MOVE.W D6,ESR
	JMP FETCH
	
EiT72:
    LEA EPROG,A4
    ADD.W A4,A0
	MOVE.W (A0),ET7
	;ACTUALIZAMOS FLAGS
	MOVE.W SR,D5
    MOVE.W ESR,D6
    JSR FLAGSZN
   	MOVE.W D6,ESR
	JMP FETCH


    ;--- FEXEC: FIN EJECUCION
    
    ;--- ISUBR: INICIO SUBRUTINAS
        ;*** Aqui debeis incluir las subrutinas que necesite vuestra solucion
        ;*** SALVO DECOD, que va en la siguiente seccion

	; ESCRIBID VUESTRO CODIGO AQUI
        
    ;--- FSUBR: FIN SUBRUTINAS

    ;--- IDECOD: INICIO DECOD
        ;*** Tras la etiqueta DECOD, debeis implementar la subrutina de 
        ;*** decodificacion, que debera ser de libreria, siguiendo la interfaz
        ;*** especificada en el enunciado


DECOD:
	
    MOVE.L D0,-(SP)
    MOVE.W 8(SP),D0
    BTST #15,D0
    BNE BIT1     
    ;BULCE SI BIT 15 = 1
    BTST #14,D0       ;0  
    BNE BIT1cero
    MOVE.W #0,8(A7)
    JMP FINAL           ;00 Id HLT

BIT1:   
    BTST #14,D0       ;1
    BNE BIT2 
    BTST #13,D0       ;10
    BNE BIT5
    BTST #12,D0       ;100
    BNE BIT6
    BTST #11,D0       ;1000
    BNE BIT7
    MOVE.W #4,8(A7)     ;10000 ID COM
    JMP FINAL
 
   
BIT2: 
    BTST #13,D0       ;11
    BNE BIT3
    BTST #12,D0       ;110
    BNE BIT4
    MOVE.W #12,10(A7)
    JMP FINAL           ;1100 ID MOV
    
BIT3:
    MOVE.W #14,10(A7)
    JMP FINAL           ;1110 Id LOA
    
BIT4: 
    MOVE.W #13,10(A7)
    JMP FINAL           ;1101 Id STO    

BIT5:
    MOVE.W #12,D0       ;101
    BNE BIT9
    MOVE.W #11,D0       ;1010
    BNE BIT10
    MOVE.W #8,10(A7)
    JMP FINAL           ;10100 ID AND
    
    
BIT6:
    BTST #11,D0       ;1001
    BNE BIT8
    MOVE.W #6,10(A7)
    JMP FINAL           ;10010 ID SUB   
    
BIT7:
    MOVE.W #5,10(A7)
    JMP FINAL           ;10001 ID ADD  
    
BIT8:  
    MOVE.W #7,10(A7) 
    JMP FINAL           ;10011 Id NEG 
   
BIT9:
    MOVE.W #11,D0       ;1011
    BNE BIT11
    MOVE.W #10,10(A7)
    JMP FINAL           ;10110 ID NOT
    
    
BIT10:
    MOVE.W #9,10(A7)
    JMP FINAL           ;10101 ID OR     
    
BIT11:
    MOVE.W #11,10(A7)
    JMP FINAL           ;10111 ID SET   
    
      
BIT1cero:               ;0
    BTST #13,D0       ;01
    BEQ BIT2cero  
    MOVE.W #3,10(A7)     ;011
    JMP FINAL           ;0110 ID JMI M
    
BIT2cero:  
    BTST #12,D0       ;010
    BNE BIT3cero
    MOVE.W #1,10(A7)
    JMP FINAL           ;0100 ID JMN M

BIT3cero:
    MOVE.W #2,10(A7)
    JMP FINAL           ;0101 ID JMZ M
    
        
FINAL:
    MOVE.L (A7)+,D0
    RTS

SUBREG:
    MOVE.W D2,-(SP)
    MOVE.W 6(SP),D2
    CMP.W #0,D2
    BEQ SR0
    CMP.W #1,D2
    BEQ SR1
    CMP.W #2,D2
    BEQ SR2
    CMP.W #3,D2
    BEQ SR3
    CMP.W #4,D2
    BEQ SR4
    CMP.W #5,D2
    BEQ SR5  
    CMP.W #6,D2
    BEQ ST6
    CMP.W #7,D2
    BEQ ST7
    
SR0:
    MOVE.W ER0,8(SP) ;MOVEMOS EL CONTENIDO DE RO AL PARÃ€METRO DE SALIDA
    MOVE.W #ER0,10(SP) ;MOVEMOS LA DIRECCION DE ERO AL PARÃ€METRO DE SALIDA
    BRA ETFSUB2

SR1:

    MOVE.W ER1,8(SP)
    MOVE.W #ER1,10(SP)
    BRA ETFSUB2
    
SR2:

    MOVE.W ER2,8(SP)
    MOVE.W #ER2,10(SP)
    BRA ETFSUB2 
SR3:
    MOVE.W ER3,8(SP)
    MOVE.W #ER3,10(SP)
    BRA ETFSUB2
SR4:
    MOVE.W ER4,8(SP)
    MOVE.W #ER4,10(SP)
    BRA ETFSUB2
SR5:
    MOVE.W ER5,8(SP)
    MOVE.W #ER5,10(SP)
    BRA ETFSUB2
ST6:
    MOVE.W ET6,8(SP)
    MOVE.W #ET6,10(SP)
    BRA ETFSUB2
ST7:
    MOVE.W ET7,8(SP)
    MOVE.W #ET7,10(SP)
    BRA ETFSUB2
ETFSUB2:
    MOVE.W (SP)+,D2
    RTS
    
    
TODOSFLAGS:
    BTST.L #3,D5 ;OBTENEMOS VALOR DEL FLAG N DEL 68K
    BNE N1
    BCLR #2,D6 ;SI N=0 PONEMOS A CERO EL BIT 2 DE ESR
    BTST.L #2,D5
    BNE Z1
    BCLR.L #0,D6
    BTST.L #0,D5
    BNE C1
    BCLR.L #1,D6
    BRA ETFTF
N1:    
    BSET.L #2,D6
    BTST.L #2,D5
    BNE Z1
    BCLR.L #0,D6
    BTST.L #0,D5
    BNE C1
    BCLR.L #1,D6
    BRA ETFTF
Z1:
    BSET.L #0,D6
    BTST.L #0,D5
    BNE C1
    BCLR.L #1,D6
    BRA ETFTF
C1:
    BSET.L #1,D6
    BRA ETFTF


ETFTF:    
    RTS    

FLAGSZN:
    BTST.L #3,D5
    BNE N12
    BCLR.L #2,D6
    BTST.L #2,D5
    BNE Z12
    BCLR.L #0,D6
    BRA ETFZN
    
N12:
    BSET.L #2,D6
    BTST.L #2,D5
    BNE Z12
    BCLR.L #0,D6
    BRA ETFZN
Z12:
    BSET.L #0,D6
    BRA ETFZN
ETFZN:
    RTS
    
    
    ;--- FDECOD: FIN DECOD
    END    START














*~Font name~Courier New~
*~Font size~10~
*~Tab type~1~
*~Tab size~4~


*~Font name~Courier New~
*~Font size~14~
*~Tab type~1~
*~Tab size~4~
